Handling timeout -> Anytime have a network call, look for both success and failure cases. For example, if using an asynchronous API in JavaScript with Promise.then(…), please ask  where the corresponding .catch(…) is. If it’s missing, almost certainly got a bug.

Retry -> If the fault indicates that the failure isn't transient or is unlikely to be successful if repeated, the application should cancel the operation and report an exception. For example, an authentication failure caused by providing invalid credentials is not likely to succeed no matter how many times it's attempted.

Rate-limiting -> Make checks locally in memory to make these rate limit determinations with minimal latency. To make local checks, relax the rate check conditions and use an eventually consistent model. For example, each node can create a data sync cycle that will synchronize with the centralized data store. Each node periodically pushes a counter increment for each consumer and window to the datastore. These pushes  update the values. The node can then retrieve the updated values to update its in-memory version. This cycle of converge → diverge → reconverge among nodes in the cluster is eventually consistent.

Circuit-breaking -> Circuit-breaking strategy manages circuit breakers through a smarter runtime environment. This is the Transparent Managed Circuit Breaker (TMCB) strategy. The upside is that service developers don't have to worry about how to use circuit breakers or programming language differences in this strategy. the drawback is that all services must be placed on top of the middleware layer which must be planned in advance.